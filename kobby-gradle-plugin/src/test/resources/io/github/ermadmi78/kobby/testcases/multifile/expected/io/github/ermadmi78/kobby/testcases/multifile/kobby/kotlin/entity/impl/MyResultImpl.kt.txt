@file:Suppress(
  "RedundantVisibilityModifier",
  "RedundantUnitReturnType",
  "FunctionName",
  "PropertyName",
  "ObjectPropertyName",
  "MemberVisibilityCanBePrivate",
  "ConstantConditionIf",
  "CanBeParameter",
  "unused",
  "RemoveExplicitTypeArguments"
)

package io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.impl

import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.GraphqlContext
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.GraphqlSubscriber
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.dto.MyResultDto
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MyMutation
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MyMutationProjection
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MyQuery
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MyQueryProjection
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MyResult
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MyResultProjection
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MySubscription
import io.github.ermadmi78.kobby.testcases.multifile.kobby.kotlin.entity.MySubscriptionProjection
import kotlin.Any
import kotlin.Boolean
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlin.collections.MutableMap
import kotlin.collections.Set
import kotlin.collections.setOf
import kotlin.error
import kotlin.text.StringBuilder

internal class MyResultImpl(
  internal val __innerContext: GraphqlContext,
  internal val __innerProjection: MyResultProjectionImpl,
  internal val __innerDto: MyResultDto
) : MyResult {
  public override val id: Long
    get() {
      if (!__innerProjection.__innerId0) {
        error("Property [id] is not available - add [id] projection to switch on it")
      }
      return __innerDto.id!!
    }

  public override val name: String?
    get() {
      if (!__innerProjection.__innerName1) {
        error("Property [name] is not available - add [name] projection to switch on it")
      }
      return __innerDto.name
    }

  public override suspend fun query(__projection: MyQueryProjection.() -> Unit): MyQuery =
      __innerContext.query(__projection)

  public override suspend fun mutation(__projection: MyMutationProjection.() -> Unit): MyMutation =
      __innerContext.mutation(__projection)

  public override fun subscription(__projection: MySubscriptionProjection.() -> Unit):
      GraphqlSubscriber<MySubscription> = __innerContext.subscription(__projection)

  public override fun MyResultProjection.__withCurrentProjection(): Unit {
    __innerProjection.___innerRepeatProjection(setOf(), this)
  }
}

internal open class MyResultProjectionImpl : MyResultProjection {
  internal var __innerId0: Boolean = false

  internal var __innerName1: Boolean = false

  public override fun id(): Unit {
    __innerId0 = true
  }

  public override fun name(): Unit {
    __innerName1 = true
  }

  @Suppress("UNUSED_PARAMETER", "UNUSED_CHANGED_VALUE")
  internal fun ___innerRepeatProjection(ignore: Set<String>, __projection: MyResultProjection):
      Unit {
    if ("id" !in ignore && __innerId0) {
      __projection.id()
    }
    if ("name" !in ignore && __innerName1) {
      __projection.name()
    }
  }

  @Suppress("UNUSED_PARAMETER", "UNUSED_CHANGED_VALUE")
  internal fun ___innerBuild(
    ignore: Set<String>,
    header: StringBuilder,
    body: StringBuilder,
    arguments: MutableMap<String, Any>
  ): Unit {
    body.append(' ').append('{')

    // Field: id
    if ("id" !in ignore && __innerId0) {
      body.append(' ').append("id")
    }

    // Field: name
    if ("name" !in ignore && __innerName1) {
      body.append(' ').append("name")
    }

    body.append(' ').append('}')
  }
}

internal fun MyResultDto.buildEntity(__innerContext: GraphqlContext,
    __innerProjection: MyResultProjectionImpl): MyResult = MyResultImpl(__innerContext,
    __innerProjection, this)
